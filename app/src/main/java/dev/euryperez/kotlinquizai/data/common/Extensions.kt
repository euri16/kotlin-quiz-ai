package dev.euryperez.kotlinquizai.data.common

import dev.euryperez.kotlinquizai.models.DifficultyLevel

fun DifficultyLevel.getSamplePrompt() = when (this) {
    DifficultyLevel.BASIC -> "[ { \"id\":\"1\", \"question\": \"What is the correct way to declare a variable as mutable in Kotlin?\", \"options\": [ { \"id\": \"1\", \"text\": \"var name: String = \\\"John\\\"\" }, { \"id\": \"2\", \"text\": \"let name: String = \\\"John\\\"\" }, { \"id\": \"3\", \"text\": \"val name: String = \\\"John\\\"\" } ], \"correct_answer\": \"1\", \"explanation\": \"The keyword 'var' is used to declare mutable variables, while 'val' is used for immutable (read-only) variables. 'let' is used for scoping.\" }, { \"id\":\"2\", \"question\": \"Which of these is NOT a valid data type in Kotlin?\", \"options\": [ { \"id\": \"1\", \"text\": \"Int\" }, { \"id\": \"2\", \"text\": \"String\" }, { \"id\": \"3\", \"text\": \"Object\" } ], \"correct_answer\": \"3\", \"explanation\": \"While everything in Kotlin is an object, 'Object' is not a specific data type like 'Int' or 'String'.\" }, { \"id\":\"3\", \"question\": \"How do you define a function in Kotlin?\", \"options\": [ { \"id\": \"1\", \"text\": \"function myFunction() {}\" }, { \"id\": \"2\", \"text\": \"fun myFunction() {}\" }, { \"id\": \"3\", \"text\": \"def myFunction() {}\" } ], \"correct_answer\": \"2\", \"explanation\": \"The keyword 'fun' is used to define functions in Kotlin.\" } ]"

    DifficultyLevel.MEDIUM -> "[ { \"id\":\"1\", \"question\": \"What is the primary constructor for a Kotlin class?\", \"options\": [ { \"id\": \"1\", \"text\": \"A constructor defined within the class body using the `constructor` keyword.\" }, { \"id\": \"2\", \"text\": \"A constructor defined in a separate companion object.\" }, { \"id\": \"3\", \"text\": \"A constructor declared in the class header after the class name.\" } ], \"correct_answer\": \"3\", \"explanation\": \"The primary constructor is part of the class header and is the most concise way to initialize a class.\" }, { \"id\":\"2\", \"question\": \"How do you define an extension function in Kotlin?\", \"options\": [ { \"id\": \"1\", \"text\": \"Create a subclass of the class you want to extend and define the function within it.\" }, { \"id\": \"2\", \"text\": \"Use the `extension` keyword before the function declaration.\" }, { \"id\": \"3\", \"text\": \"Prefix the function name with the name of the class you want to extend.\" } ], \"correct_answer\": \"3\", \"explanation\": \"Extension functions allow you to add new functions to existing classes without modifying their source code.\" }, { \"id\":\"3\", \"question\": \"What is the purpose of a sealed class in Kotlin?\", \"options\": [ { \"id\": \"1\", \"text\": \"To create a class with a private constructor.\" }, { \"id\": \"2\", \"text\": \"To restrict the hierarchy of a class to a limited set of subclasses.\" }, { \"id\": \"3\", \"text\": \"To define a class that cannot be instantiated.\" } ], \"correct_answer\": \"2\", \"explanation\": \"Sealed classes allow you to control the inheritance hierarchy, making it easier to manage and reason about the possible types.\" } ]"

    DifficultyLevel.ADVANCED -> "[ { \"id\":\"1\", \"question\": \"In Kotlin, what is the primary difference between using a 'lateinit' modifier on a property and using a nullable type with initialization?\",        \"options\": [            {                \"id\": \"1\",                \"text\": \"'lateinit' allows for non-null property access after initialization, while a nullable type requires null checks.\"            },            {                \"id\": \"2\",                \"text\": \"'lateinit' properties can only be used with var, while nullable types can be used with both var and val.\"            },            {                \"id\": \"3\",                \"text\": \"'lateinit' properties are initialized at compile time, while nullable types are initialized at runtime.\"            }        ],        \"correct_answer\": \"1\",        \"explanation\": \"The 'lateinit' modifier allows you to avoid null checks after initialization, assuming the property will be set before use. Nullable types require explicit null checks even after initialization.\"    },    { \"id\":\"2\",  \"question\": \"How does Kotlin's type inference system work with generic functions?\",        \"options\": [            {                \"id\": \"1\",                \"text\": \"The compiler always infers the most specific type possible based on the function arguments.\"            },            {                \"id\": \"2\",                \"text\": \"Type inference is disabled for generic functions to ensure type safety.\"            },            {                \"id\": \"3\",                \"text\": \"The compiler uses a combination of argument types and expected return type to infer the generic type parameters.\"            }        ],        \"correct_answer\": \"3\",        \"explanation\": \"Kotlin's type inference considers both the provided arguments and the expected return type to determine the most appropriate type parameters for a generic function.\"    },    {  \"id\":\"3\",   \"question\": \"What is the purpose of using a 'sealed' modifier on a class in Kotlin?\",        \"options\": [            {                \"id\": \"1\",                \"text\": \"It restricts class inheritance to within the same module.\"            },            {                \"id\": \"2\",                \"text\": \"It prevents the class from being instantiated directly.\"            },            {                \"id\": \"3\",                \"text\": \"It creates a closed set of possible subclasses for that class.\"            }        ],        \"correct_answer\": \"3\",        \"explanation\": \"A 'sealed' class defines a restricted hierarchy, allowing only a specific set of subclasses that are known at compile time. This enables exhaustive checks in 'when' expressions.\"    }]"
}
